import os
import zipfile
from datetime import datetime
from pathlib import Path
import fnmatch
import re

# ============ å¯è°ƒå‚æ•° ============

MAX_FILE_SIZE_MB = 25
OUTPUT_TO_DESKTOP = True

# âœ… å…³é”®ï¼šåªæ”¶â€œæºç /é…ç½®â€æ–‡ä»¶ï¼ˆå¼ºçƒˆæ¨èï¼‰
SOURCE_ONLY = True

# âœ… æ˜¯å¦ä» .env è‡ªåŠ¨ç”Ÿæˆ .env.exampleï¼ˆä»…ä¿ç•™ keyï¼Œä¸ä¿ç•™å€¼ï¼‰
GENERATE_ENV_EXAMPLE = True
# å¦‚æœ .env.example å·²å­˜åœ¨ï¼Œæ˜¯å¦ä»å¼ºåˆ¶è¦†ç›–é‡å»º
FORCE_REGEN_ENV_EXAMPLE = True
# ä¼˜å…ˆä»è¿™äº›æ–‡ä»¶ç”Ÿæˆï¼ˆæ‰¾åˆ°ç¬¬ä¸€ä¸ªå­˜åœ¨çš„å°±ç”¨ï¼‰
ENV_CANDIDATES = [".env", ".env.local", ".env.production", ".env.development"]

# åªè¦è·¯å¾„é‡ŒåŒ…å«è¿™äº›ç›®å½•åï¼ˆä»»æ„å±‚çº§ï¼‰ï¼Œå°±è·³è¿‡ï¼ˆå¸¸è§æ•°æ®/äº§ç‰©ï¼‰
EXCLUDE_DIRS = {
    "node_modules", ".next", ".git", ".turbo", ".cache", ".vscode", ".idea",
    "__pycache__", "dist", "build", "coverage", ".output", ".vercel",
    "tmp", "temp", "logs",
    ".pnpm-store",
}

# é¢å¤–ï¼šæŒ‰â€œç›®å½•åæ¨¡å¼â€æ’é™¤ï¼ˆå¸¸è§ volume/data ç›®å½•ï¼‰
EXCLUDE_DIRNAME_GLOBS = [
    "*data*", "*volume*", "*volumes*",  "*cache*",
    "*loki*", "*grafana*", "*promtail*",
]

# æ°¸ä¹…æ’é™¤çš„æ–‡ä»¶åæ¨¡å¼ï¼ˆæ•æ„Ÿ / äºŒè¿›åˆ¶ / å·¨å¤§ï¼‰
EXCLUDE_FILE_GLOBS = [
    # secretsï¼ˆæ³¨æ„ï¼š.env.example é€šè¿‡ should_exclude çš„ä¾‹å¤–é€»è¾‘ä¿ç•™ï¼‰
    ".env", ".env.*",
    "*.pem", "*.key", "*.p12", "*.pfx", "*.crt", "*.cer", "*.der",
    "*id_rsa*", "*id_ed25519*",

    # db / logs
    "*.sqlite", "*.sqlite3", "*.db", "*.log",

    # archives
    "*.zip", "*.tar", "*.tgz", "*.gz", "*.7z", "*.rar",

    # media/fonts (é€šå¸¸ä½“ç§¯å¤§)
    "*.png", "*.jpg", "*.jpeg", "*.webp", "*.gif", "*.bmp", "*.ico",
    "*.mp4", "*.mov", "*.avi", "*.mkv",
    "*.mp3", "*.wav", "*.flac",
    "*.pdf",
    "*.ttf", "*.otf", "*.woff", "*.woff2",
]

# âœ… SOURCE_ONLY=True æ—¶ï¼Œä¼šç”¨è¿™ä¸ªâ€œå…è®¸åç¼€ç™½åå•â€
# ï¼ˆmonorepo + å°ç¨‹åºéª¨æ¶ï¼šè¡¥å…… .wxml/.wxss/.wxsï¼‰
ALLOW_EXTS = {
    ".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs",
    ".json", ".md", ".txt",
    ".yml", ".yaml",
    ".prisma", ".sql",
    ".sh", ".bash", ".zsh", ".ps1", ".py",
    ".toml", ".ini", ".properties",
    ".css", ".scss",
    ".html",
    # WeChat Mini Program
    ".wxml", ".wxss", ".wxs",
}

# æ ¹ç›®å½•é¢å¤–å¼ºåˆ¶åŒ…å«ï¼ˆå³ä½¿æ²¡åç¼€ï¼‰
FORCE_INCLUDE_FILENAMES = {
    # docker
    "Dockerfile",
    "docker-compose.yml",
    "docker-compose.yaml",
    "docker-compose.prod.yml",

    # monorepo / pkg managers
    "package.json",
    "pnpm-lock.yaml",
    "pnpm-workspace.yaml",
    "pnpm-workspace.yml",
    "package-lock.json",
    "yarn.lock",

    # next / tooling
    "next.config.js",
    "next.config.mjs",
    "next.config.ts",
    "tsconfig.json",
    "postcss.config.js",
    "tailwind.config.js",

    # docs
    "MODULES.md",
    "OPERATIONS.md",
    "PROMPTING.md",
    "SECURITY.md",
    "README.md",
    "LICENSE",

    # optional dotfiles
    ".npmrc",
    ".nvmrc",
    ".node-version",
    ".editorconfig",
    ".gitignore",
    ".gitattributes",
    ".dockerignore",
}

TOP_LARGEST_PRINT = 30  # æ‰“å°æœ€å¤§çš„ N ä¸ªæ–‡ä»¶ç”¨äºå®šä½

# ============ å·¥å…·å‡½æ•° ============

def get_desktop_dir() -> Path:
    home = Path.home()
    desktop = home / "Desktop"
    return desktop if desktop.exists() else home

def match_any_glob(name: str, globs) -> bool:
    for g in globs:
        if fnmatch.fnmatch(name, g):
            return True
    return False

def sanitize_env_line(line: str) -> str:
    """
    å°† .env çš„ä¸€è¡Œè½¬æ¢ä¸º .env.example çš„å®‰å…¨æ ¼å¼ï¼šä¿ç•™ keyï¼Œä¸ä¿ç•™ valueã€‚
    è§„åˆ™ï¼š
    - æ³¨é‡Š/ç©ºè¡ŒåŸæ ·ä¿ç•™
    - export KEY=VALUE -> KEY=
    - KEY=VALUE -> KEY=
    - KEY:VALUE è¿™ç±»ä¸å¸¸è§æ ¼å¼ä¸å¤„ç†ï¼ˆåŸæ ·ä¿ç•™ï¼‰
    """
    raw = line.rstrip("\n")
    stripped = raw.strip()

    if stripped == "" or stripped.startswith("#"):
        return raw

    # keep inline comments but strip values
    # handle "export KEY=VALUE"
    m = re.match(r"^\s*export\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$", raw)
    if m:
        key = m.group(1)
        return f"{key}="

    # handle "KEY=VALUE"
    m = re.match(r"^\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*(.*)$", raw)
    if m:
        key = m.group(1)
        return f"{key}="

    return raw

def ensure_env_example(base_dir: Path) -> None:
    if not GENERATE_ENV_EXAMPLE:
        return

    target = base_dir / ".env.example"
    if target.exists() and not FORCE_REGEN_ENV_EXAMPLE:
        return

    src = None
    for cand in ENV_CANDIDATES:
        p = base_dir / cand
        if p.exists() and p.is_file():
            src = p
            break

    if src is None:
        # æ²¡æœ‰ .env å¯ç”Ÿæˆï¼šå¦‚æœå·²æœ‰ .env.example å°±ç®—æé†’ï¼›å¦åˆ™ä»€ä¹ˆä¹Ÿä¸åš
        return

    lines = src.read_text(encoding="utf-8", errors="ignore").splitlines()
    out_lines = []
    out_lines.append("# Auto-generated by make_minimal_zip.py")
    out_lines.append(f"# Source: {src.name}")
    out_lines.append("")

    for ln in lines:
        out_lines.append(sanitize_env_line(ln))

    target.write_text("\n".join(out_lines).rstrip() + "\n", encoding="utf-8")

def should_exclude(rel_path: str) -> bool:
    parts = Path(rel_path).parts

    # ç›®å½•å±‚é¢æ’é™¤
    for part in parts[:-1]:
        if part in EXCLUDE_DIRS:
            return True
        if match_any_glob(part.lower(), [p.lower() for p in EXCLUDE_DIRNAME_GLOBS]):
            return True

    filename = os.path.basename(rel_path)

    # âœ… ä¾‹å¤–ï¼šå…è®¸æŠŠ .env.example æ‰“è¿› zipï¼ˆæ–¹ä¾¿å›¢é˜Ÿ/AI å¤ç°å˜é‡ç»“æ„ï¼‰
    # æ³¨æ„ï¼šå› ä¸º EXCLUDE_FILE_GLOBS é‡Œæœ‰ ".env.*"ï¼Œæ‰€ä»¥å¿…é¡»åœ¨å®ƒä¹‹å‰æ”¾è¡Œ
    if filename == ".env.example":
        return False

    # æ–‡ä»¶æ¨¡å¼æ’é™¤
    if match_any_glob(filename, EXCLUDE_FILE_GLOBS) or match_any_glob(rel_path, EXCLUDE_FILE_GLOBS):
        return True

    # SOURCE_ONLYï¼šåªæ”¶ç™½åå•åç¼€ï¼ˆä½†å…è®¸å¼ºåˆ¶æ–‡ä»¶åï¼‰
    if SOURCE_ONLY:
        if filename in FORCE_INCLUDE_FILENAMES:
            return False
        ext = Path(filename).suffix.lower()
        if ext in ALLOW_EXTS:
            return False
        return True  # éç™½åå•ä¸€å¾‹æ’é™¤

    return False

def add_file(zipf: zipfile.ZipFile, file_path: Path, base_dir: Path):
    rel = str(file_path.relative_to(base_dir)).replace("\\", "/")
    zipf.write(str(file_path), rel)
    return rel

def zip_project(base_dir: str):
    base_dir = Path(base_dir).resolve()

    # âœ… åœ¨æ‰“åŒ…å‰ç”Ÿæˆ .env.exampleï¼ˆå¦‚æœèƒ½æ‰¾åˆ° .envï¼‰
    ensure_env_example(base_dir)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    zip_name = f"customor-qc-app_{timestamp}.zip" if SOURCE_ONLY else f"sean-brain-monorepo_full_{timestamp}.zip"

    out_dir = get_desktop_dir() if OUTPUT_TO_DESKTOP else base_dir
    output_path = (out_dir / zip_name).resolve()

    print(f"é¡¹ç›®æ ¹ç›®å½•: {base_dir}")
    print(f"è¾“å‡ºæ–‡ä»¶  : {output_path}")
    print(f"æ¨¡å¼      : {'SOURCE_ONLY(æºç /é…ç½®ç™½åå•)' if SOURCE_ONLY else 'FULL(é™¤æ’é™¤é¡¹)'}")
    print("-" * 60)

    max_bytes = MAX_FILE_SIZE_MB * 1024 * 1024

    added = 0
    skipped = 0
    skipped_big = 0
    largest = []  # (size, rel)

    with zipfile.ZipFile(str(output_path), "w", zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(str(base_dir)):
            root_path = Path(root)

            # è¿‡æ»¤ç›®å½•ï¼ˆé˜»æ­¢å‘ä¸‹ walkï¼‰
            pruned = []
            for d in dirs:
                if d in EXCLUDE_DIRS:
                    continue
                if match_any_glob(d.lower(), [p.lower() for p in EXCLUDE_DIRNAME_GLOBS]):
                    continue
                pruned.append(d)
            dirs[:] = pruned

            for fname in files:
                full_path = root_path / fname
                if not full_path.is_file():
                    continue

                rel = str(full_path.relative_to(base_dir)).replace("\\", "/")

                if should_exclude(rel):
                    skipped += 1
                    continue

                try:
                    size = full_path.stat().st_size
                except OSError:
                    skipped += 1
                    continue

                if size > max_bytes:
                    skipped_big += 1
                    continue

                add_file(zipf, full_path, base_dir)
                added += 1
                largest.append((size, rel))

    largest.sort(reverse=True)
    print("\nâœ… æ‰“åŒ…å®Œæˆï¼")
    print(f"å·²åŠ å…¥æ–‡ä»¶æ•°: {added}")
    print(f"è·³è¿‡(æ’é™¤è§„åˆ™): {skipped}")
    print(f"è·³è¿‡(è¶…å¤§æ–‡ä»¶): {skipped_big}")
    print(f"ç”Ÿæˆæ–‡ä»¶: {output_path}")

    print(f"\nğŸ“Œ æœ€å¤§çš„ {min(TOP_LARGEST_PRINT, len(largest))} ä¸ªæ–‡ä»¶ï¼ˆæ–¹ä¾¿ä½ å®šä½ä¸ºä»€ä¹ˆä¼šå¤§ï¼‰:")
    for size, rel in largest[:TOP_LARGEST_PRINT]:
        print(f"  {size/1024/1024:.2f} MB  {rel}")

if __name__ == "__main__":
    zip_project(".")
